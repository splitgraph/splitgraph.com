export const meta = {
  id: "first_steps",
  title: "First steps"
};

# First Steps

## Pull a data image

The 2016 US Presidential Election precinct-level returns dataset ([source](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/LYWX3D)) has 2 million rows, takes up 500MB as a CSV file and only 25MB in Splitgraph. It's a perfect example to showcase more powerful features of Splitgraph.

Clone the image. Note this will only download the image's metadata. No actual data is transferred until it's required, unless you explicitly ask for it.

```shell-session
$ sgr clone splitgraph/2016_election:latest
Gathering remote metadata...
Fetched metadata for 1 image, 1 table, 20 objects and 1 tag.

$ sgr show splitgraph/2016_election:latest
Image splitgraph/2016_election:3835145ada3f07cad99087d1b1071122d58c48783cbfe4694c101d35651fba90

Created at 2019-10-10T15:51:41.122370
Size: 26.75 MiB
No parent (root image)

Tables:
  precinct_results

$ sgr table splitgraph/2016_election:latest precinct_results
Table splitgraph/2016_election:3835145ada3f07cad99087d1b1071122d58c48783cbfe4694c101d35651fba90/precinct_results

Size: 26.75 MiB
Rows: 1989234
Columns:
  year (integer)
  stage (character varying)
  special (boolean)
  state (character varying)
  state_postal (character varying)
  state_fips (bigint)
  state_icpsr (bigint)
  county_name (character varying)
  county_fips (bigint)
  county_ansi (bigint)
  county_lat (numeric)
  county_long (numeric)
  jurisdiction (character varying)
  precinct (character varying)
  candidate (character varying)
  candidate_normalized (character varying)
  office (character varying)
  district (character varying)
  writein (boolean)
  party (character varying)
  mode (character varying)
  votes (bigint)
  candidate_opensecrets (character varying)
  candidate_wikidata (character varying)
  candidate_party (character varying)
  candidate_last (character varying)
  candidate_first (character varying)
  candidate_middle (character varying)
  candidate_full (character varying)
  candidate_suffix (character varying)
  candidate_nickname (character varying)
  candidate_fec (character varying)
  candidate_fec_name (character varying)
  candidate_google (character varying)
  candidate_govtrack (character varying)
  candidate_icpsr (character varying)
  candidate_maplight (character varying)
  id (integer, PK)

Objects:
  o960395135f32c2da7b4b9371da06b0a9d00925472df2ec1ef687acf6f24894
  o07f95f9944d673d8cc05a5b5174253adc513d377ccd811928ae0fe6923e451
  o40e4e46594064e402ccdb914ffb8c9f59267a67b33420cf704073729a6671b
  o1ccf32547f73be8047c3de06760b32c1077c3bd0b0d8309575ebe9ab8eb86c
  oaf3cca3210e1903f06872d0041097dd284423958352d5cd7b5209eceec6cbf
  odc1546c25cac950eca4b551642305d548172b554643f046a16cd9da236c895
  oe60d81ef239980ceb5869fd787d159f227b59b66ab6ceef18aed45cd62ae8f
  o9e77e782f8bda76be6a3f4d29b82661e32d614f7d63230619e8635b9b2b512
  of06f6cfb7bd95047bb49bcd3ab6b98da63c2605aa9659c064cee3bd708b0e4
  o0671aabeb9d4ce362515624616a5a202503db99d7a83007bfdf63fd71b91af
...
```

## Query the image

To interact this image, you could check it out, which would download all objects that it consists
of and create a series of tables for you that any application that supports PostgreSQL
can query.

However, imagine if this dataset were a few hundred gigabytes large. Should you really need to
download all of it to query a few rows?

Splitgraph objects contain metadata that can help it to discard objects that are irrelevant to a
query. The US election dataset is stored ordered by county FIPS code and so queries that filter
on this column only need to download a couple of objects instead of the whole dataset.

Let's check out the image into a so called "layered querying" schema. This sets up a Postgres
foreign data wrapper for this image that acts as a shim and presents itself as normal Postgres
table to clients.

```shell-session
$ sgr checkout --layered splitgraph/2016_election:latest

Checked out splitgraph/2016_election:3835145ada3f.
```

We're interested in precinct-level election result for District of Columbia (FIPS code 11001).

```shell-session
$ sgr sql -s splitgraph/2016_election "EXPLAIN SELECT candidate_normalized, SUM(votes) FROM precinct_results WHERE county_fips=11001 GROUP BY candidate_normalized"

GroupAggregate  (cost=71991481.18..71992900.45 rows=1 width=64)
  Group Key: candidate_normalized
  ->  Sort  (cost=71991481.18..71991954.27 rows=189234 width=380)
        Sort Key: candidate_normalized
        ->  Foreign Scan on precinct_results  (cost=20.00..71908920.00 rows=189234 width=380)
              Filter: (county_fips = 11001)
              Multicorn: Objects removed by filter: 18
              Multicorn: Scan through 2 object(s) (2.55 MiB)
JIT:
  Functions: 7
...
```

Here, we can see that this query will only download two objects. Let's actually run it: behind
the scenes, this will lazily download required data.

```shell-session
$ sgr sql -s splitgraph/2016_election "SELECT candidate_normalized, SUM(votes) FROM precinct_results WHERE county_fips=11001 GROUP BY candidate_normalized"

clinton 282830
in      6551
johnson 4906
stein   4258
trump   12723
```

Note that you don't need `sgr sql` to run this query: any Postgres client will work.

It is also possible to add a bloom filter to some columns to speed up queries to datasets that
consist of objects that span overlapping value ranges. The [bloom filter example](https://github.com/splitgraph/splitgraph/tree/master/examples/bloom-filter) adds a bloom filter on the `county_name`
column of this dataset, speeding up lookups on county name.
